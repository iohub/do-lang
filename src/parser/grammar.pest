

keyword = _{
    "fn" | "let" | "if" | "return" | "else" | "for" |
    "false" | "true" | "while" | "loop" | "for" |
    "break" | "continue" | "enum" | "impl" | "use" |
    "struct" | "pub" | "mut" | "int" | "float" | "str"
}

basic_val = @{
    "int" | "float" | "str"
}

WHITESPACE = _{ (" ") | ("\t") | ("\u{000C}") | ("\r") | ("\n") }

// token define
whitespace = _{ " " | "\t" | "\r" | "\n" }
alpha = _{ 'a'..'z' | 'A'..'Z' | "_" }
alphanumeric = _{ alpha | '0'..'9' }
nonzero = _{ '1'..'9' }
digit = _{ '0'..'9' }
integer = @{ "0" | (nonzero ~ digit*) }
float = @{ integer+ ~ "." ~ integer+ }
identifier = @{ (('a'..'z') | ('A'..'Z') | ("_")) ~ (('a'..'z') | ('A'..'Z') | ("_") | ('0'..'9'))* }
bool_literal = @{ "true" | "false" }
literal_char = { whitespace | (!"\"" ~ ANY) }
str = @{ "b\"" ~ literal_char* ~ "\"" }

// operator
op_or = { "||" }
op_assign = { "=" }
op_and = { "&&" }
op_eq = { "==" }
op_ne = { "!=" }
op_le = { "<=" }
op_ge = { ">=" }
op_gt = { "<" }
op_lt = { ">" }
op_not = { "!" }
op_modulo = { "%" }


// top level of program module
module = _{ SOI ~ decl_func* ~ statement* ~ EOI }

// grammar define
decl_func = { "fn" ~ identifier ~  func_args ~ ("->") ~ basic_val ~ block }
func_args = { ("(") ~ (func_arg ~ ",")* ~ func_arg? ~ (")") }
func_arg = { identifier ~ (":") ~ basic_val }
block = { ("{") ~ statement* ~ ("}") }

statement = { 
    var_decl |
    assign_stmt |
    while_stmt |
    if_stmt |
    (expr ~ (";")) |
    comment
}

var_decl = _{ let_decl_init }
let_decl = { ("let") ~ identifier ~ (";") }
let_decl_init = { ("let") ~ identifier ~  ("=") ~ (identifier | func_call| values) ~ (";") }
assign_stmt = { identifier ~ op_assign ~ (identifier | values)}

values = { 
    integer |
    float |
    str
}

while_stmt = { "while" ~ expr ~ block }
if_stmt = { "if" ~ expr ~ block ~ ("else" ~ block)* }
comment = _{ "//" ~ (!("\r" | "\n") ~ ANY)* ~ ("\n" | "\r\n" | "\r") }

op_infix = {
    op_or |
    op_and |
    op_eq |
    op_ne |
    op_le |
    op_ge |
    op_gt |
    op_lt
}

infix = { (comparison | func_call) ~ op_infix ~ (comparison | func_call) }
prefix = { op_not? ~ (identifier | func_call) }
expr = { infix | prefix }
call_arg = { identifier | values }
comparison = { identifier | values }
func_call = { identifier ~ ("(") ~ (call_arg ~ ",")* ~ call_arg ~ ")" }

